## 优化算法介绍

### 数据流优化

数据流优化通过分析程序中数据的传递和使用方式改进程序性能，主要涉及LLVM IR的use-def链的使用。

#### 常量传播&常量传播

#### 死代码消除

#### 公共子表达式消除

代表测例：`instruction-combining-*.sysu.c`
难度：***

公共子表达式消除（Common Subexpression Elimination，CSE）是一个非常经典的优化算法，如果一个表达式E在计算得到后没有变化，且同时作为多条指令的操作数被使用，那么E能够被称为公共子表达式：

```C++
// (a + b)是d和e的公共子表达式
int d = a + b - c;
int e = a + b + c;

// CSE优化后
int tmp = a + b;
int d = tmp - c;
int e = a + b;
```

CSE的优化原理是比较简单的，本质上就是重复复用之前已经计算得到的结果，避免重复计算。根据CSE的原理可以引出两个问题：

1. 如何判断一个表达式E是否是公共子表达式？
2. 如何判断一个表达式E的值在计算后没有变化?

对于上述两个问题，LLVM IR的设计能够为我们提供很大的帮助。我们知道LLVM IR本质上满足静态单赋值（Static Single Assignment，SSA），即对于编号相同的操作数，我们能够保证它们一定相等。那么上述两个问题可以通过以下方法判断，对于某条指令`%3 = bin_op %1, %2`：

1. 对该指令后的`%6 = bin_op %4, %5`指令，判断操作数`%4, %5`与`%1, %2`是否相同。若操作数相同，则`%3`与`%6`一定相同，那么所有操作数为`%6`的指令都可以使用`%3`替代，同时`%6`也无需计算，能够删除该指令。
2. 对于访存相关的指令，我们难以直接判断相同内存地址的值在不同时间是否相同，判断需要增加访存分析，一般这样的指令我们保守地选择不删除。

指令`%3`和`%6`之间的间隔（即判断的指令窗口大小）可以自行定义，间隔的大小决定了优化的范围。间隔越大，判断公共子表达式的范围越大，优化效果越好，但相应地编译时间也会延长。更高效的方法是使用全局值编号（Global Value Number，GVN）寻找公共子表达式，该算法在此不作介绍，同学们感兴趣可以自行查找资料。

#### 指令合并

### 控制流优化

控制流优化通过分析代码块的跳转、分支、循环等结构来改进程序性能。

#### 循环无关变量移动

#### 循环展开

#### 控制流简化

### 指令级优化

指令级优化主要包括指令调度、指令选择等内容，将单条或多条指令转化为运行效率更高的指令。

#### mem2reg

#### 强度削弱

#### 代数恒等式

### 模块级优化

模块级优化主要寻求跨函数的优化机会。

#### 函数内联

### 访存优化

访存优化通过分析程序的访存模式，消除非必要的访存指令，并提升访存行为的局部性。

#### 死存储消除

### 高级优化

#### 自动向量化

包括向量化内存访问与向量化计算。

#### 自动并行

自动识别可以并行执行的代码块，并将部分代码由串行执行优化为并行执行，充分利用CPU的计算资源。
